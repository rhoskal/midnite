module Set exposing
    ( Set(..)
    , diff
    , empty
    , empty?
    , fold_left
    , fold_right
    , from_list
    , insert
    , intersect
    , keep
    , map
    , member?
    , partition
    , reject
    , remove
    , singleton
    , size
    , subset?
    , superset?
    , to_list
    , union
    )

open TreeMap as TM
open Unit using (Unit)

## A collection of unique values with guaranteed ordering.
## Operations like insert, remove, and lookup have O(log n) complexity.
##
## @since 0.1.0
type alias Set a =
    Set (TM.TreeMap a Unit)

## Create an empty set.
##
## @since 0.1.0
##
## ```
## ➢ Set.empty
## {} : Set a
## ```
let empty : Set a =
    todo "not implemented"

## Determine if a set is empty.
##
## @since 0.1.0
##
## ```
## ➢ Set.empty? Set.empty
## True : Bool
##
## ➢ Set.empty? (Set.singleton 1)
## False : Bool
## ```
let empty? : Set a -> Bool =
    todo "not implemented"

## Create a set with one value.
##
## @since 0.1.0
##
## ```
## ➢ Set.singleton 42
## {42} : Set Int
## ```
let singleton : comparable -> Set comparable =
    todo "not implemented"

## Insert a value into a set.
##
## @since 0.1.0
##
## ```
## ➢ Set.insert 2 (Set.singleton 1)
## {1, 2} : Set Int
##
## ➢ Set.insert 1 (Set.singleton 1)
## {1} : Set Int
## ```
let insert : comparable -> Set comparable -> Set comparable =
    todo "not implemented"

## Remove a value from a set. If the value is not found, no changes are made.
##
## @since 0.1.0
##
## ```
## ➢ Set.remove 2 (Set.from_list [1, 2, 3])
## {1, 3} : Set Int
## ```
let remove : comparable -> Set comparable -> Set comparable =
    todo "not implemented"

## Determine if a value is in a set.
##
## @since 0.1.0
##
## ```
## ➢ Set.member? 2 (Set.from_list [1, 2, 3])
## True : Bool
##
## ➢ Set.member? 4 (Set.from_list [1, 2, 3])
## False : Bool
## ```
let member? : comparable -> Set comparable -> Bool =
    todo "not implemented"

## Determine the number of elements in a set.
##
## @since 0.1.0
##
## ```
## ➢ Set.size (Set.from_list [1, 2, 3])
## 3 : Int
## ```
let size : Set a -> Int =
    todo "not implemented"

## Get the union of two sets. Keep all values.
##
## @since 0.1.0
##
## ```
## ➢ Set.union (Set.from_list [2, 3]) (Set.from_list [1, 2])
## {1, 2, 3} : Set Int
## ```
let union : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

## Get the intersection of two sets. Keeps values that appear in both sets.
##
## @since 0.1.0
##
## ```
## ➢ Set.intersect (Set.from_list [2, 3]) (Set.from_list [1, 2])
## {2} : Set Int
## ```
let intersect : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

## Get the difference between the first set and the second. Keeps values
## that do not appear in the second set.
##
## @since 0.1.0
##
## ```
## ➢ Set.diff (Set.from_list [2, 3, 4]) (Set.from_list [1, 2, 3])
## {4} : Set Int
## ```
let diff : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

## Determine if the first set is a subset of the second set.
##
## @since 0.1.0
##
## ```
## ➢ Set.subset? (Set.from_list [1, 2, 3]) (Set.from_list [1, 2])
## False : Bool
##
## ➢ Set.subset? (Set.from_list [1, 2, 3]) (Set.from_list [1, 4])
## False : Bool
## ```
let subset? : Set comparable -> Set comparable -> Bool =
    todo "not implemented"

## Determine if the first set is a superset of the second set.
##
## @since 0.1.0
##
## ```
## ➢ Set.superset? (Set.from_list [1, 2]) (Set.from_list [1, 2, 3])
## False : Bool
##
## ➢ Set.superset? (Set.from_list [1, 4]) (Set.from_list [1, 2, 3])
## False : Bool
## ```
let superset? : Set comparable -> Set comparable -> Bool =
    todo "not implemented"

## Convert a set into a list, sorted from lowest to highest.
##
## @since 0.1.0
##
## ```
## ➢ Set.to_list (Set.from_list [3, 1, 2])
## [1, 2, 3] : List Int
## ```
let to_list : Set a -> List a =
    todo "not implemented"

## Convert a list into a set, removing any duplicates.
##
## @since 0.1.0
##
## ```
## ➢ Set.from_list [1, 2, 1, 3, 2]
## {1, 2, 3} : Set Int
## ```
let from_list : List comparable -> Set comparable =
    todo "not implemented"

## Fold over the values in a set, in order from lowest to highest.
##
## @since 0.1.0
##
## ```
## ➢ Set.fold_left (fn x acc => acc + x) 0 (Set.from_list [1, 2, 3])
## 6 : Int
## ```
let fold_left : (a -> b -> b) -> b -> Set a -> b =
    todo "not implemented"

## Fold over the values in a set, in order from highest to lowest.
##
## @since 0.1.0
##
## ```
## ➢ Set.fold_right (fn x acc => acc + x) 0 (Set.from_list [1, 2, 3])
## 6 : Int
## ```
let fold_right : (a -> b -> b) -> b -> Set a -> b =
    todo "not implemented"

## Map a function onto a set, creating a new set with no duplicates.
##
## @since 0.1.0
##
## ```
## ➢ Set.map (fn x => x * 2) (Set.from_list [1, 2, 3])
## {2, 4, 6} : Set Int
##
## ➢ Set.map (fn x => mod x 2) (Set.from_list [1, 2, 3, 4])
## {0, 1} : Set Int
## ```
let map : (comparable -> comparable2) -> Set comparable -> Set comparable2 =
    todo "not implemented"

## Only keep elements that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ Set.keep (fn x => mod x 2 == 0) (Set.from_list [1, 2, 3, 4])
## {2, 4} : Set Int
## ```
let keep : (comparable -> Bool) -> Set comparable -> Set comparable =
    todo "not implemented"

## Returns a set by excluding the elements which satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ Set.reject (fn x => mod x 2 == 0) (Set.from_list [1, 2, 3, 4])
## {1, 3} : Set Int
## ```
let reject : (comparable -> Bool) -> Set comparable -> Set comparable =
    todo "not implemented"

## Create two new sets. The first contains all the elements that passed the
## given test, and the second contains all the elements that did not.
##
## @since 0.1.0
##
## ```
## ➢ Set.partition (fn x => mod x 2 == 0) (Set.from_list [1, 2, 3, 4])
## ({2, 4}, {1, 3}) : (Set Int, Set Int)
## ```
let partition : (comparable -> Bool) -> Set comparable -> (Set comparable, Set comparable) =
    todo "not implemented"
