## A map from keys to values, based on a balanced binary tree.
## Keys must be comparable.
module TreeMap exposing
    ( TreeMap
    , empty
    , empty?
    , fold_left
    , fold_right
    , from_list
    , get
    , insert
    , keys
    , map
    , remove
    , singleton
    , size
    , to_list
    , union
    , values
    , intersect
    , diff
    , keep
    , reject
    , partition
    )

type TreeMap k v =
    TreeMap

## Create an empty tree map.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.empty
## {} : TreeMap k v
## ```
let empty : TreeMap k v =
    tree_map_empty

## Determine if a tree map is empty.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.empty? TreeMap.empty
## True : Bool
##
## ➢ TreeMap.empty? (TreeMap.singleton 1 "one")
## False : Bool
## ```
let empty? (map : TreeMap k v) : Bool =
    tree_map_is_empty map

## Create a tree map with a single key-value pair.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.singleton 1 "one"
## {1: "one"} : TreeMap Int String
## ```
let singleton (key : comparable) (value : v) : TreeMap comparable v =
    tree_map_singleton key value

## Get the value associated with a key.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.get 1 (TreeMap.singleton 1 "one")
## Some "one" : Maybe String
##
## ➢ TreeMap.get 2 (TreeMap.singleton 1 "one")
## None : Maybe String
## ```
let get (key : comparable) (map : TreeMap comparable v) : Maybe v =
    tree_map_get key map

## Insert a key-value pair into a tree map.
## If the key already exists, the value is updated.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.insert 2 "two" (TreeMap.singleton 1 "one")
## {1: "one", 2: "two"} : TreeMap Int String
##
## ➢ TreeMap.insert 1 "ONE" (TreeMap.singleton 1 "one")
## {1: "ONE"} : TreeMap Int String
## ```
let insert (key : comparable) (value : v) (map : TreeMap comparable v) : TreeMap comparable v =
    tree_map_insert key value map

## Remove a key-value pair from a tree map.
## If the key is not found, no changes are made.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.remove 1 (TreeMap.from_list [(1, "one"), (2, "two")])
## {2: "two"} : TreeMap Int String
## ```
let remove (key : comparable) (map : TreeMap comparable v) : TreeMap comparable v =
    tree_map_remove key map

## Determine the number of key-value pairs in a tree map.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.size (TreeMap.from_list [(1, "one"), (2, "two")])
## 2 : Int
## ```
let size (map : TreeMap k v) : Int =
    tree_map_size map

## Convert a tree map into a list of key-value pairs, sorted by key.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.to_list (TreeMap.from_list [(2, "two"), (1, "one")])
## [(1, "one"), (2, "two")] : List (Int, String)
## ```
let to_list (map : TreeMap k v) : List (k, v) =
    tree_map_to_list map

## Convert a list of key-value pairs into a tree map.
## If there are duplicate keys, later values overwrite earlier ones.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.from_list [(1, "one"), (2, "two"), (1, "ONE")]
## {1: "ONE", 2: "two"} : TreeMap Int String
## ```
let from_list (list : List (comparable, v)) : TreeMap comparable v =
    tree_map_from_list list

## Get a list of all keys in a tree map, sorted.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.keys (TreeMap.from_list [(1, "one"), (2, "two")])
## [1, 2] : List Int
## ```
let keys (map : TreeMap k v) : List k =
    tree_map_keys map


## Get a list of all values in a tree map, in key order.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.values (TreeMap.from_list [(1, "one"), (2, "two")])
## ["one", "two"] : List String
## ```
let values (map : TreeMap k v) : List v =
    tree_map_values map

## Combine two tree maps, favoring values from the second map when keys overlap.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.union (TreeMap.from_list [(1, "one"), (2, "two")]) (TreeMap.from_list [(2, "TWO"), (3, "three")])
## {1: "one", 2: "TWO", 3: "three"} : TreeMap Int String
## ```
let union (map1 : TreeMap comparable v) (map2 : TreeMap comparable v) : TreeMap comparable v =
    tree_map_union map1 map2

## Keep only key-value pairs where the key exists in both maps.
## Values are taken from the first map.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.intersect (TreeMap.from_list [(1, "one"), (2, "two")]) (TreeMap.from_list [(2, "TWO"), (3, "three")])
## {2: "two"} : TreeMap Int String
## ```
let intersect (map1 : TreeMap comparable v) (map2 : TreeMap comparable v) : TreeMap comparable v =
    tree_map_intersect map1 map2

## Keep only key-value pairs where the key exists in the first map but not the second.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.diff (TreeMap.from_list [(1, "one"), (2, "two")]) (TreeMap.from_list [(2, "TWO"), (3, "three")])
## {1: "one"} : TreeMap Int String
## ```
let diff (map1 : TreeMap comparable v) (map2 : TreeMap comparable v) : TreeMap comparable v =
    tree_map_diff map1 map2

## Fold over the key-value pairs in a tree map, in key order from lowest to highest.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.fold_left (fn k v acc => acc ++ v) "" (TreeMap.from_list [(1, "one"), (2, "two")])
## "onetwo" : String
## ```
let fold_left (f : k -> v -> acc -> acc) (init : acc) (map : TreeMap k v) : acc =
    tree_map_fold_left f init map

## Fold over the key-value pairs in a tree map, in key order from highest to lowest.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.fold_right (fn k v acc => acc ++ v) "" (TreeMap.from_list [(1, "one"), (2, "two")])
## "twoone" : String
## ```
let fold_right (f : k -> v -> acc -> acc) (init : acc) (map : TreeMap k v) : acc =
    tree_map_fold_right f init map

## Transform values in a tree map.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.map (fn k v => String.to_upper v) (TreeMap.from_list [(1, "one"), (2, "two")])
## {1: "ONE", 2: "TWO"} : TreeMap Int String
## ```
let map (f : k -> v -> v2) (map : TreeMap k v) : TreeMap k v2 =
    tree_map_map f map

## Keep only key-value pairs that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.keep (fn k v => mod k 2 == 0) (TreeMap.from_list [(1, "one"), (2, "two")])
## {2: "two"} : TreeMap Int String
## ```
let keep (pred : comparable -> v -> Bool) (map : TreeMap comparable v) : TreeMap comparable v =
    tree_map_keep map pred

## Remove key-value pairs that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.reject (fn k v => mod k 2 == 0) (TreeMap.from_list [(1, "one"), (2, "two")])
## {1: "one"} : TreeMap Int String
## ```
let reject (pred : comparable -> v -> Bool) (map : TreeMap comparable v) : TreeMap comparable v =
    tree_map_reject pred map

## Create two new maps. The first contains all key-value pairs that passed the
## given test, and the second contains all key-value pairs that did not.
##
## @since 0.1.0
##
## ```
## ➢ TreeMap.partition (fn k v => mod k 2 == 0) (TreeMap.from_list [(1, "one"), (2, "two")])
## ({2: "two"}, {1: "one"}) : (TreeMap Int String, TreeMap Int String)
## ```
let partition (pred : comparable -> v -> Bool) (map : TreeMap comparable v) : (TreeMap comparable v, TreeMap comparable v) =
    tree_map_partition pred map

foreign tree_map_empty : TreeMap k v =
    "zig_tree_map_empty"

foreign tree_map_is_empty : TreeMap k v -> Bool =
    "zig_tree_map_is_empty"

foreign tree_map_singleton : comparable -> v -> TreeMap comparable v =
    "zig_tree_map_singleton"

foreign tree_map_get : TreeMap comparable v -> comparable -> Maybe v =
    "zig_tree_map_get"

foreign tree_map_insert : TreeMap comparable v -> comparable -> v -> TreeMap comparable v =
    "zig_tree_map_insert"

foreign tree_map_remove : TreeMap comparable v -> comparable -> TreeMap comparable v =
    "zig_tree_map_remove"

foreign tree_map_size : TreeMap k v -> Int =
    "zig_tree_map_size"

foreign tree_map_to_list : TreeMap k v -> List (k, v) =
    "zig_tree_map_to_list"

foreign tree_map_from_list : List (comparable, v) -> TreeMap comparable v =
    "zig_tree_map_from_list"

foreign tree_map_keys : TreeMap k v -> List k =
    "zig_tree_map_keys"

foreign tree_map_values : TreeMap k v -> List v =
    "zig_tree_map_values"

foreign tree_map_union : TreeMap comparable v -> TreeMap comparable v -> TreeMap comparable v =
    "zig_tree_map_union"

foreign tree_map_intersect : TreeMap comparable v -> TreeMap comparable v -> TreeMap comparable v =
    "zig_tree_map_intersect"

foreign tree_map_diff : TreeMap comparable v -> TreeMap comparable v -> TreeMap comparable v =
    "zig_tree_map_diff"

foreign tree_map_fold_left : TreeMap k v -> (k -> v -> acc -> acc) -> acc -> acc =
    "zig_tree_map_fold_left"

foreign tree_map_fold_right : TreeMap k v -> (k -> v -> acc -> acc) -> acc -> acc =
    "zig_tree_map_fold_right"

foreign tree_map_map : TreeMap k v -> (k -> v -> v2) -> TreeMap k v2 =
    "zig_tree_map_map"

foreign tree_map_keep : TreeMap comparable v -> (comparable -> v -> Bool) -> TreeMap comparable v =
    "zig_tree_map_keep"

foreign tree_map_reject : TreeMap comparable v -> (comparable -> v -> Bool) -> TreeMap comparable v =
    "zig_tree_map_reject"

foreign tree_map_partition : TreeMap comparable v -> (comparable -> v -> Bool) -> (TreeMap comparable v, TreeMap comparable v) =
    "zig_tree_map_partition"
