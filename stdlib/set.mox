module Set exposing
  ( Set
  , diff
  , empty
  , empty?
  , fold_left
  , fold_right
  , from_list
  , insert
  , intersect
  , keep
  , map
  , member
  , parition
  , reject
  , remove
  , singleton
  , size
  , to_list
  , union
  )

  ## A collection of unique values without any particular order.
  type Set a =
    ...

  ## Create an empty set.
  let empty : Set a =
    todo "not implemented"

  ## Determine if a set is empty.
  let empty? : Set a => Bool =
    \set =>
      todo "not implemented"

  ## Create a set with one value.
  let singleton : comparable -> Set comparable =
    todo "not implemented"

  ## Insert a value into a set.
  let insert : comparable -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Remove a value from a set. If the value is not found, no changes are made.
  let remove : comparable -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Determine if a value is in a set.
  let member? : comparable -> Set comparable -> Bool =
    todo "not implemented"

  ## Determine the number of elements in a set.
  let size : Set a -> Int =
    todo "not implemented"

  ## Get the union of two sets. Keep all values.
  let union : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Get the intersection of two sets. Keeps values that appear in both sets.
  let intersect : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Get the difference between the first set and the second. Keeps values
  that do not appear in the second set.
  let diff : Set comparable -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Convert a set into a list, sorted from lowest to highest.
  let to_list : Set a -> List a =
    todo "not implemented"

  ## Convert a list into a set, removing any duplicates.
  let from_list : List comparable -> Set comparable =
    todo "not implemented"

  ## Fold over the values in a set, in order from lowest to highest.
  let fold_left : (a -> b -> b) -> b -> Set a -> b =
    todo "not implemented"

  ## Fold over the values in a set, in order from highest to lowest.
  let fold_right : (a -> b -> b) -> b -> Set a -> b =
    todo "not implemented"

  ## Map a function onto a set, creating a new set with no duplicates.
  let map : (comparable -> comparable2) -> Set comparable -> Set comparable2 =
    todo "not implemented"

  ## Only keep elements that satisfy the given predicate
  let keep : (comparable -> Bool) -> Set comparable -> Set comparable =
    todo "not implemented"

  # Returns a set by excluding the elements which satisfy the given predicate
  let reject : (comparable -> Bool) -> Set comparable -> Set comparable =
    todo "not implemented"

  ## Create two new sets. The first contains all the elements that passed the
  ## given test, and the second contains all the elements that did not.
  let partition : (comparable -> Bool) -> Set comparable -> (Set comparable, Set comparable) =
    todo "not implemented"
end
