module String exposing
    ( Pattern(..)
    , all?
    , any?
    , append
    , at
    , concat
    , contains?
    , drop_right
    , drop_while
    , empty?
    , ends_with?
    , fold_left
    , fold_right
    , from_char
    , index_of
    , indexes_of
    , join
    , keep
    , last_index_of
    , lines
    , map
    , match?
    , pad
    , pad_left
    , pad_right
    , reject
    , repeat
    , replace
    , reverse
    , size
    , slice
    , split_at
    , split_on
    , starts_with?
    , take_left
    , take_right
    , take_while
    , to_float
    , to_int
    , to_lower
    , to_upper
    , trim
    , trim_left
    , trim_right
    , words
    )

type Pattern =
    Pattern(String)

## Calculate the number of characters in a string.
##
## @since 0.1.0
##
## ```
## ➢ String.size "foobar"
## 6 : Int
## ```
let size (str : String) : Int =
    string_size str

## Append one string to another.
##
## @since 0.1.0
##
## ```
## ➢ String.append "foo" "bar"
## "foobar" : String
## ```
let append (str1 : String) (str2 : String) : String =
    string_append str1 str2

## Concatenate a list of strings into a single string.
##
## @since 0.1.0
##
## ```
## ➢ String.concat ["foo", "bar", "baz"]
## "foobarbaz" : String
## ```
let concat (list : List String) : String =
    string_concat list

## Join a list of strings with a given pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.join ", " ["apple", "banana", "cherry"]
## "apple, banana, cherry" : String
## ```
let join (pattern : Pattern) (list : List String) : String =
    let (Pattern p) = pattern
    string_join p list

## Take the leftmost `n` characters from a string.
##
## @since 0.1.0
##
## ```
## ➢ String.take_left 2 "hello"
## "he" : String
## ```
let take_left (n : Int) (str : String) : String =
    if n < 1 then
        ""
    else
        slice 0 n str

## Take the rightmost `n` characters from a string.
##
## @since 0.1.0
##
## ```
## ➢ String.take_right 2 "hello"
## "lo" : String
## ```
let take_right (n : Int) (str : String) : String =
    let len = size str
    if n <= 0 then
        ""
    else if n >= len then
        str
    else
        slice (len - n) len str

## Take characters from a string while a predicate is true.
##
## @since 0.1.0
##
## ```
## ➢ String.take_while (fn c => c == 'a') "aaabbc"
## "aaa" : String
## ```
let take_while (predicate : Char -> Bool) (str : String) : String =
    let len = size str
    let find_end (i : Int) : Int =
        match string_at i str on
            | None => i
            | Some c =>
                if predicate c then
                    find_end (i + 1)
                else
                    i
    string_substr 0 (find_end 0) str

## Drop the leftmost `n` characters from a string.
##
## @since 0.1.0
##
## ```
## ➢ String.drop_left 2 "hello"
## "llo" : String
## ```
let drop_left (n : Int) (str : String) : String =
    let len = size str
    if n <= 0 then
        str
    else if n >= len then
        ""
    else
        slice n len str

## Drop the rightmost `n` characters from a string.
##
## @since 0.1.0
##
## ```
## ➢ String.drop_right 2 "hello"
## "hel" : String
## ```
let drop_right (n : Int) (str : String) : String =
    let len = size str
    if n <= 0 then
        str
    else if n >= len then
        ""
    else
        slice 0 (len - n) str

## Drop characters from a string while a predicate is true.
##
## @since 0.1.0
##
## ```
## ➢ String.drop_while (fn c => c == 'a') "aaabbc"
## "bbc" : String
## ```
let drop_while (predicate : Char -> Bool) (str : String) : String =
    todo "not implemented"

## Check if a string contains a given pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.contains? "world" "hello world"
## true : Bool
## ```
let contains? (pattern : Pattern) (str : String) : Bool =
    todo "not implemented"

## Break a string into words, splitting on chunks of whitespace.
##
## @since 0.1.0
##
## ```
## ➢ String.words "hello world"
## ["hello", "world"] : List String
##
## ➢ String.words "  multiple   spaces   "
## ["multiple", "spaces"] : List String
## ```
let words (str : String) : List String =
    todo "not implemented"

## Break a string into lines, splitting on newlines.
##
## @since 0.1.0
##
## ```
## ➢ String.lines "hello\nworld"
## ["hello", "world"] : List String
##
## ➢ String.lines "multiple\n\nblank\nlines"
## ["multiple", "", "blank", "lines"] : List String
## ```
let lines (str : String) : List String =
    todo "not implemented"

## Find the first occurrence of a pattern in a string.
##
## @since 0.1.0
##
## ```
## ➢ String.index_of (Pattern "world") "hello world"
## Some 6 : Maybe Int
##
## ➢ String.index_of (Pattern "moon") "hello world"
## None : Maybe Int
## ```
let index_of (pattern : Pattern) (str : String) : Maybe Int =
    let (Pattern p) = pattern
    string_index_of p str

## Find the last occurrence of a pattern in a string.
##
## @since 0.1.0
##
## ```
## ➢ String.last_index_of (Pattern "hello") "hello hello world"
## Some 6 : Maybe Int
##
## ➢ String.last_index_of (Pattern "moon") "hello world"
## None : Maybe Int
## ```
let last_index_of (pattern : Pattern) (str : String) : Maybe Int =
    let (Pattern p) = pattern
    string_last_index_of p str

## Split a string using a given pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.split_on (Pattern ",") "foo,bar"
## ["foo", "bar"] : List String
## ```
let split_on (pattern : Pattern) (str : String) : List String =
    let (Pattern p) = pattern
    string_split p str

## Split a string using a given pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.split_at 3 "foobar"
## ("foo", "bar") : (String, String)
## ```
let split_at (n : Int) (str : String) : (String, String) =
    todo "not implemented"

## Take a substring given a start and end index.
##
## @since 0.1.0
##
## ```
## ➢ String.slice 1 3 "abcd"
## "bc" : String
## ```
let slice (start : Int) (end : Int) (str : String) : String =
    string_slice start end str

## Convert a string to all lower case.
##
## @since 0.1.0
##
## ```
## ➢ String.to_lower "FOOBAR"
## "foobar" : String
## ```
let to_lower (str : String) : String =
    string_to_lower str

## Convert a string to all upper case.
##
## @since 0.1.0
##
## ```
## ➢ String.to_upper "foobar"
## "FOOBAR" : String
## ```
let to_upper (str : String) : String =
    string_to_upper str

## Reverse a string.
##
## @since 0.1.0
##
## ```
## ➢ String.reverse "foobar"
## "raboof" : String
## ```
let reverse (str : String) : String =
    string_reverse str

## Repeat a string *n* times.
##
## @since 0.1.0
##
## ```
## ➢ String.repeat 3 "ha"
## "hahaha" : String
## ```
let repeat (n : Int) (str : String) : String =
    string_repeat n str

## Test whether a string is empty.
##
## @since 0.1.0
##
## ```
## ➢ String.empty? ""
## True : Bool
##
## ➢ String.empty? "hello"
## False : Bool
## ```
let empty?(str : String) -> Bool =
    str == ""

## Check if a string starts with a given prefix.
##
## @since 0.1.0
##
## ```
## ➢ String.starts_with? "a" "abc"
## True : Bool
## ```
let starts_with? (prefix : String) (str : String) : Bool =
    string_starts_with prefix str

## Check if a string ends with a given suffix.
##
## @since 0.1.0
##
## ```
## ➢ String.ends_with? "c" "abc"
## True : Bool
## ```
let ends_with? (suffix : String) (str : String) : Bool =
    string_ends_with suffix str

## Replace all occurrences of some pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.replace (Pattern "-") (Pattern "_") "foo-bar-baz"
## "foo_bar_baz" : String
## ```
let replace (old : String) (new : String) (str : String) : String =
    string_replace old new str

## Remove whitespace from both sides of a string.
##
## @since 0.1.0
##
## ```
## ➢ String.trim "  foo  "
## "foo" : String
## ```
let trim (str : String) : String =
    string_trim str

## Remove whitespace from the left of a string.
##
## @since 0.1.0
##
## ```
## ➢ String.trim_left "  foo"
## "foo" : String
## ```
let trim_left (str : String) : String =
    todo "not implemented"

## Remove whitespace from the right of a string.
##
## @since 0.1.0
##
## ```
## ➢ String.trim_right "foo  "
## "foo" : String
## ```
let trim_right (str : String) : String =
    todo "not implemented"

## Pad a string on both sides until it has a given length.
##
## @since 0.1.0
##
## ```
## ➢ String.pad 10 '_' "foobar"
## "__foobar__" : String
## ```
let pad (length : Int) (char : Char) (str : String) : String =
    todo "not implemented"

## Pad a string from the left until it has a given length.
##
## @since 0.1.0
##
## ```
## ➢ String.pad_left 6 (Pattern " ") "foo"
## "   foo" : String
## ```
let pad_left (length : Int) (char : Char) (str : String) : String =
    todo "not implemented"

## Pad a string from the right until it has a given length.
##
## @since 0.1.0
##
## ```
## ➢ String.pad_right 6 (Pattern " ") "foo"
## "foo   " : String
## ```
let pad_right (length : Int) (char : Char) (str : String) : String =
    todo "not implemented"

## Find all indexes of a pattern in a string.
##
## @since 0.1.0
##
## ```
## ➢ String.indexes_of "ana" "banana"
## [1, 3] : List Int
## ```
let indexes_of (pattern : Pattern) (str : String) : List Int =
    todo "not implemented"

## Convert a string to an integer, if possible.
##
## @since 0.1.0
##
## ```
## ➢ String.to_int "42"
## Some 42 : Maybe Int
## ```
let to_int (str : String) : Maybe Int =
    todo "not implemented"

## Convert a string to a floating-point number, if possible.
##
## @since 0.1.0
##
## ```
## ➢ String.to_float "3.14"
## Some 3.14 : Maybe Float
## ```
let to_float (str : String) : Maybe Float =
    todo "not implemented"

## Convert a character to a string.
##
## @since 0.1.0
##
## ```
## ➢ String.from_char 'A'
## "A" : String
## ```
let from_char (char : Char) : String =
    todo "not implemented"

## Apply a function to each character in a string, producing a new string.
##
## @since 0.1.0
##
## ```
## ➢ String.map Char.to_upper "hello"
## "HELLO" : String
## ```
let map (f : Char -> Char) (str : String) : String =
    fold_left (fn acc c => acc <> from_char (f c)) "" str

## Keep only the characters that pass the predicate test.
##
## @since 0.1.0
##
## ```
## ➢ String.keep (fn c => c != ' ') "hello world"
## "helloworld" : String
## ```
let keep (predicate : Char -> Bool) (str : String) : String =
    fold_left (fn acc c => if predicate c then acc <> from_char c else acc) "" str

## Remove characters that match a predicate.
##
## @since 0.1.0
##
## ```
## ➢ String.reject (fn c => c == 'l') "hello world"
## "heo word" : String
## ```
let reject (predicate : Char -> Bool) (str : String) : String =
    todo "not implemented"

## Fold over a string from left to right.
##
## @since 0.1.0
##
## ```
## ➢ String.fold_left (fn acc c => acc + Char.to_int c) 0 "abc"
## 294 : Int
## ```
let fold_left (f : a -> Char -> a) (init : a) (str : String) : a =
    todo "not implemented"

## Fold over a string from right to left.
##
## @since 0.1.0
##
## ```
## ➢ String.fold_right (fn c acc => from_char c <> acc) "" "abc"
## "cba" : String
## ```
let fold_right (f : Char -> a -> a) (init : a) (str : String) : a =
    todo "not implemented"

## Check if any character in a string matches a predicate.
##
## @since 0.1.0
##
## ```
## ➢ String.any? (fn c => c == 'a') "hello"
## false : Bool
## ```
let any? (predicate : Char -> Bool) (str : String) : Bool =
    fold_left (fn acc c => acc || predicate c) False str

## Check if all characters in a string match a predicate.
##
## @since 0.1.0
##
## ```
## ➢ String.all? (fn c => c == 'a') "aaaa"
## true : Bool
## ```
let all? (predicate : Char -> Bool) (str : String) : Bool =
    fold_left (fn acc c => acc && predicate c) True str

## Get the character at a given index in a string.
##
## @since 0.1.0
##
## ```
## ➢ String.at 1 "hello"
## Some 'e' : Maybe Char
## ```
let at (index : Int) (str : String) : Maybe Char =
    string_at index str

## Check if a string matches a given pattern.
##
## @since 0.1.0
##
## ```
## ➢ String.match? "[0-9]+" "123"
## true : Bool
## ```
let match? (pattern : Pattern) (str : String) : Bool =
    todo "not implemented"

foreign string_size : String -> Int =
    "zig_string_size"

foreign string_append : String -> String -> String =
    "zig_string_append"

foreign string_concat : String -> String -> String =
    "zig_string_concat"

foreign string_join : String -> List String -> String =
    "zig_string_concat"

foreign string_substr : String -> Int -> Int -> String =
    "zig_string_substr"

foreign string_index_of : String -> String -> Maybe Int =
    "zig_string_index_of"

foreign string_last_index_of : String -> String -> Maybe Int =
    "zig_string_last_index_of"

foreign string_split : String -> String -> List String =
    "zig_string_split"

foreign string_to_upper : String -> String =
    "zig_string_to_upper"

foreign string_to_lower : String -> String =
    "zig_string_to_lower"

foreign string_reverse : String -> String =
    "zig_string_reverse"

foreign string_repeat : Int -> String -> String =
    "zig_string_repeat"

foreign string_starts_with : String -> String -> Bool =
    "zig_string_starts_with"

foreign string_ends_with : String -> String -> Bool =
    "zig_string_ends_with"

foreign string_replace : String -> String -> String -> String =
    "zig_string_replace"

foreign string_trim : String -> String =
    "zig_string_trim"
