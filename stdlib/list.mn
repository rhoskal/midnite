module List exposing
    ( List(..)
    , all?
    , alter_at
    , any?
    , collect_map
    , cons
    , delete_at
    , empty?
    , flatten
    , fold_left
    , fold_right
    , head
    , insert_at
    , keep
    , last
    , map
    , maximum
    , member?
    , minimum
    , modify_at
    , product
    , range
    , reject
    , reverse
    , singleton
    , size
    , sum
    , tail
    )

type List a =
    | Nil
    | a :: List a

## Add an element to the beginning of a list.
##
## @since 0.1.0
##
## ```
## ➢ List.cons 1 [2, 3]
## [1, 2, 3] : List Int
##
## ➢ List.cons 42 Nil
## [42] : List Int
## ```
let cons (x : a) (xs : List a) : List a =
    list_cons x xs

## Create a list with only one element.
##
## @since 0.1.0
##
## ```
## ➢ List.singleton 42
## [42] : List Int
## ```
let singleton (x : a) : List a =
    x :: Nil

## Test whether a list is empty.
##
## @since 0.1.0
##
## ```
## ➢ List.empty? [42]
## False : Bool
##
## ➢ List.empty? Nil
## True : Bool
## ```
let empty? (list : List a) : Bool =
    match list on
    | Nil => True
    | _ => False

## Get the size of a list.
##
## @since 0.1.0
##
## ```
## ➢ List.size [42]
## 1 : Int
##
## ➢ List.size Nil
## 0 : Int
## ```
let size (list : List a) : Int =
    list_size list

## Determine if a list contains a value.
##
## @since 0.1.0
##
## ```
## ➢ List.member? 42 [42]
## True : Bool
##
## ➢ List.member? 0 Nil
## False : Bool
## ```
let member? (elem : a) (list : List a) : Bool =
    any? (fn x => x == elem) list

## Determine if all elements satisfy some test.
##
## @since 0.1.0
##
## ```
## ➢ List.all? Math.even? [2, 4, 6]
## True : Bool
## ```
let all? (predicate : a -> Bool) (list : List a) : Bool =
    not (any? (not << predicate) list)

## Determine if any elements satisfy some test.
##
## @since 0.1.0
##
## ```
## ➢ List.any? (fn x => x == 4) [2, 4, 6]
## True : Bool
## ```
let any? (predicate : a -> Bool) (list : List a) : Bool =
    match list on
        | Nil => False
        | x :: xs =>
            if predicate x then
                True
            else
                any? predicate xs

## Reduce a list from the left.
##
## @since 0.1.0
##
## ```
## ➢ List.fold_left (fn acc x => acc + x) 0 [1, 2, 3]
## 6 : Int
##
## ➢ List.fold_left (fn acc x => acc ++ Int.to_string x) "" [1, 2, 3]
## "123" : String
## ```
let fold_left (f : b -> a -> b) (acc : b) (list : List a) : b =
    match list on
    | Nil => acc
    | x :: xs => fold_left f (f acc x) xs

## Reduce a list from the right.
##
## @since 0.1.0
##
## ```
## ➢ List.fold_right (fn x acc => x + acc) 0 [1, 2, 3]
## 6 : Int
##
## ➢ List.fold_right (fn x acc => Int.to_string x ++ acc) "" [1, 2, 3]
## "123" : String
## ```
let fold_right (f : a -> b -> b) (acc : b) (list : List a) : b =
    match list on
    | Nil => acc
    | x :: xs => f x (fold_right f acc xs)

## Get the first element in a list, or `None` if the list is empty.
##
## @since 0.1.0
##
## ```
## ➢ List.head [1, 2, 3]
## Some 1 : Maybe Int
##
## ➢ List.head (Nil : List Int)
## None : Maybe Int
## ```
let head (list : List a) : Maybe a =
    match list on
    | Nil => None
    | x :: _ => Some x

## Get all but the first element of a list, or `None` if the list is empty.
##
## @since 0.1.0
##
## ```
## ➢ List.tail [1, 2, 3]
## Some [2, 3] : Maybe (List Int)
##
## ➢ List.tail (Nil : List Int)
## None : Maybe (List Int)
## ```
let tail (list : List a) : Maybe (List a) =
    match list on
    | Nil => None
    | _ :: xs => Some xs

## Get the last element in a list, or `None` if the list is empty.
##
## @since 0.1.0
##
## ```
## ➢ List.last [1, 2, 3]
## Some 3 : Maybe Int
##
## ➢ List.last (Nil : List Int)
## None : Maybe Int
## ```
let last (list : List a) : Maybe a =
    match list on
    | Nil => None
    | x :: Nil => Some x
    | _ :: xs => last xs

## Reverse a list.
##
## @since 0.1.0
##
## ```
## ➢ reverse [1, 2, 3]
## [3, 2, 1] : List Int
##
## ➢ reverse (Nil : List Int)
## Nil : List Int
## ```
let reverse (list : List a) : List a =
    fold_left (fn acc x => x :: acc) Nil list

## Apply a function to every element in a list.
##
## @since 0.1.0
##
## ```
## ➢ List.map (fn x => x * 2) [1, 2, 3]
## [2, 4, 6] : List Int
## ```
let map (f : a -> b) (list : List a) : List b =
    fold_right (fn x acc => f x :: acc) Nil list

## Keep elements that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ List.keep (fn x => x > 1) [1, 2, 3]
## [2, 3] : List Int
##
## ➢ List.keep Math.even? [1, 2, 3, 4]
## [2, 4] : List Int
## ```
let keep (predicate : a -> Bool) (list : List a) : List a =
    match list on
    | Nil => Nil
    | x :: xs =>
        if predicate x then
            x :: keep predicate xs
        else
            keep predicate xs

## Exclude elements that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ List.reject (fn x => x > 1) [1, 2, 3]
## [1] : List Int
##
## ➢ List.reject Math.even? [1, 2, 3, 4]
## [1, 3] : List Int
## ```
let reject (predicate : a -> Bool) (list : List a) : List a =
    match list on
    | Nil => Nil
    | x :: xs =>
        if predicate x then
            reject predicate xs
        else
            x :: reject predicate xs

## Applies filter and map simultaneously.
##
## @since 0.1.0
##
## ```
## ➢ List.collect_map (fn x => if Math.even? x then Some (x * 2) else None) [1, 2, 3, 4]
## [4, 8] : List Int
## ```
let collect_map (f : a -> Maybe b) (list : List a) : List b =
    match list on
    | Nil => Nil
    | x :: xs =>
        match f x on
        | Some y => y :: collect_map f xs
        | None => collect_map f xs

## Create a list of numbers, every element increasing by one.
##
## @since 0.1.0
##
## ```
## ➢ List.range 1 5
## [1, 2, 3, 4, 5] : List Int
##
## ➢ List.range 10 12
## [10, 11, 12] : List Int
##
## ➢ List.range 5 1
## Nil : List Int
## ```
let range (start : Int) (end : Int) : List a =
    list_range start end

## Insert an element at the specified index in a list.
## Returns `None` if the index is out of bounds.
##
## @since 0.1.0
##
## ```
## ➢ List.insert_at 2 3 [1, 2, 4]
## Some [1, 2, 3, 4] : Maybe (List Int)
##
## ➢ List.insert_at 0 0 [1, 2, 3]
## Some [0, 1, 2, 3] : Maybe (List Int)
##
## ➢ List.insert_at 10 4 [1, 2, 3]
## None : Maybe (List Int)
## ```
let insert_at (index : Int) (elem : a) (list : List a) : Maybe (List a) =
    match list on
    | _ when index == 0 => Some (elem :: list)
    | x :: xs =>
        insert_at (index - 1) elem xs
        |> Maybe.map (fn rest => x :: rest)
    | _ => None

## Delete an element at the specified index in a list.
## Returns `None` if the index is out of bounds.
##
## @since 0.1.0
##
## ```
## ➢ List.delete_at 2  [1, 2, 3, 4]
## Some [1, 2, 4] : Maybe (List Int)
##
## ➢ List.delete_at 0 [1, 2, 3]
## Some [2, 3] : Maybe (List Int)
##
## ➢ List.delete_at 10 [1, 2, 3]
## None : Maybe (List Int)
## ```
let delete_at (index : Int) (list : List a) : Maybe (List a) =
    match list on
    | _ when index == 0 =>
        match list on
        | _ :: xs => Some xs
        | _ => None
    | x :: xs =>
        delete_at (index - 1) xs
        |> Maybe.map (fn rest => x :: rest)
    | _ => None

## Apply a function to the element at the specified index.
## Returns `None` if the index is out of bounds.
##
## @since 0.1.0
##
## ```
## ➢ List.modify_at 2 (fn x => x * 10) [1, 2, 3, 4]
## Some [1, 2, 30, 4] : Maybe (List Int)
##
## ➢ List.modify_at 1 String.to_upper ["a", "b", "c"]
## Some ["a", "B", "c"] : Maybe (List String)
##
## ➢ List.modify_at 10 (fn x => x + 1) [1, 2, 3]
## None : Maybe (List Int)
## ```
let modify_at (index : Int) (f : a -> a) (list : List a) : Maybe (List a) =
    alter_at index (fn x => Some (f x)) list

## Apply a function that returns `Maybe` to the element at the specified index.
## The function can transform or remove the element.
## Returns `None` if the index is out of bounds or if the function returns `None`.
##
## @since 0.1.0
##
## ```
## ➢ List.alter_at 2 (fn x => Some (x * 10)) [1, 2, 3, 4]
## Some [1, 2, 30, 4] : Maybe (List Int)
##
## ➢ List.alter_at 2 (fn x => if x > 2 then Some (x * 10) else None) [1, 2, 3, 4]
## Some [1, 2, 30, 4] : Maybe (List Int)
##
## ➢ List.alter_at 10 (fn x => Some (x + 1)) [1, 2, 3]
## None : Maybe (List Int)
## ```
let alter_at (index : Int) (f : a -> Maybe a) (list : List a) : Maybe (List a) =
    match list on
    | _ when index == 0 =>
        match list on
        | x :: xs => Maybe.map (fn y => y :: xs) (f x)
        | _ => None
    | x :: xs =>
        alter_at (index - 1) f xs
        |> Maybe.map (fn rest => x :: rest)
    | _ => None

## Flatten a list of lists into a single list.
##
## @since 0.1.0
##
## ```
## ➢ List.flatten [[1, 2], [3, 4], [5]]
## [1, 2, 3, 4, 5] : List Int
##
## ➢ List.flatten [[1, 2], Nil, [3, 4]]
## [1, 2, 3, 4] : List Int
##
## ➢ List.flatten (Nil : List (List Int))
## Nil : List Int
## ```
let flatten (list : List (List a)) : List a =
    list_flatten list

## Find the maximum element in a list.
##
## @since 0.1.0
##
## ```
## ➢ List.maximum [1, 4, 2]
## Some 4 : Maybe Int
##
## ➢ List.maximum (Nil : Maybe Int)
## None : Maybe Int
## ```
let maximum (list : List comparable) : Maybe comparable =
    match list on
    | x :: xs => Some (fold_left x max xs)
    | _ => None

## Find the minimum element in a non-empty list.
##
## @since 0.1.0
##
## ```
## ➢ List.minimum [3, 2, 1]
## Some 1 : Maybe Int
##
## ➢ List.minimum (Nil : Maybe Int)
## None : Maybe Int
## ```
let minimum (list : List comparable) : Maybe comparable =
    match list on
    | x :: xs => Some (fold_left x min xs)
    | _ => None

## Get the sum of the list elements.
##
## @since 0.1.0
##
## ```
## ➢ List.sum [3, 2, 1]
## 6.0 : Float
##
## ➢ List.sum (Nil : List Float)
## 0.0 : Float
## ```
let sum (list : List Number) : Number =
    list_sum list

## Get the product of the list elements.
##
## @since 0.1.0
##
## ```
## ➢ List.product [2, 4, 6]
## 48 : Int
##
## ➢ List.product (Nil : Int)
## 1 : Int
## ```
let product (list : List Number) : Number =
    fold_left 1 (fn acc x => acc * x) list

foreign list_cons : a -> List a -> List a =
    "zig_list_cons"

foreign list_size : List a -> Int =
    "zig_list_size"

foreign list_range : Int -> Int -> List a =
    "zig_list_range"

foreign list_flatten : List (List a) -> List a =
    "zig_list_flatten"

foreign list_sum : List Number -> Number =
    "zig_list_sum"
