module Map exposing
    ( Map
    , diff
    , empty
    , empty?
    , fold_left
    , fold_right
    , from_list
    , get
    , insert
    , intersect
    , keys
    , keep
    , map
    , member?
    , partition
    , reject
    , remove
    , singleton
    , size
    , to_list
    , union
    , update
    , values
    )

open TreeMap as TM

## A mapping from keys to values, optimized for lookup, insertion, and deletion.
## Keys must be comparable.
##
## @since 0.1.0
type Map k v =
    Map (TM.TreeMap k v)

## Create an empty map.
##
## @since 0.1.0
##
## ```
## ➢ Map.empty
## {} : Map k v
## ```
let empty : Map k v =
    Map TM.empty

## Determine if a map is empty.
##
## @since 0.1.0
##
## ```
## ➢ Map.empty? (Map.empty())
## True : Bool
##
## ➢ Map.empty? (Map.singleton 1 "one")
## False : Bool
## ```
let empty? (map : Map k v) : Bool =
    todo "not implemented"

## Create a map with a single key-value pair.
##
## @since 0.1.0
##
## ```
## ➢ Map.singleton 1 "one"
## {1: "one"} : Map Int String
## ```
let singleton (key : comparable) (value : v) : Map comparable v =
    todo "not implemented"

## Get the value associated with a key.
##
## @since 0.1.0
##
## ```
## ➢ Map.get 1 (Map.singleton 1 "one")
## Some "one" : Maybe String
##
## ➢ Map.get 2 (Map.singleton 1 "one")
## None : Maybe String
## ```
let get (key : comparable) (map : Map comparable v) : Maybe v =
    todo "not implemented"

## Determine if a map contains a key.
##
## @since 0.1.0
##
## ```
## ➢ Map.member? 1 (Map.singleton 1 "one")
## True : Bool
##
## ➢ Map.member? 2 (Map.singleton 1 "one")
## False : Bool
## ```
let member? (key : comparable) (map : Map comparable v) : Bool =
    todo "not implemented"

## Insert a key-value pair into a map.
## If the key already exists, the value is updated.
##
## @since 0.1.0
##
## ```
## ➢ Map.insert 2 "two" (Map.singleton 1 "one")
## {1: "one", 2: "two"} : Map Int String
##
## ➢ Map.insert 1 "ONE" (Map.singleton 1 "one")
## {1: "ONE"} : Map Int String
## ```
let insert (key : comparable) (value : v) (map : Map comparable v) : Map comparable v =
    todo "not implemented"

## Update the value at a specific key using the given function.
## If the key does not exist, the map is not modified.
##
## @since 0.1.0
##
## ```
## ➢ Map.update 1 String.to_upper (Map.singleton 1 "one")
## {1: "ONE"} : Map Int String
##
## ➢ Map.update 2 String.to_upper (Map.singleton 1 "one")
## {1: "one"} : Map Int String
## ```
let update (key : comparable) (f : v -> v) (map : Map comparable v) : Map comparable v =
    todo "not implemented"

## Remove a key-value pair from a map.
## If the key is not found, no changes are made.
##
## @since 0.1.0
##
## ```
## ➢ Map.remove 1 (Map.from_list [(1, "one"), (2, "two")])
## {2: "two"} : Map Int String
## ```
let remove (key : comparable) (map : Map comparable v) : Map comparable v =
    todo "not implemented"

## Determine the number of key-value pairs in a map.
##
## @since 0.1.0
##
## ```
## ➢ Map.size (Map.from_list [(1, "one"), (2, "two")])
## 2 : Int
## ```
let size (map : Map k v) : Int =
    todo "not implemented"

## Convert a map into a list of key-value pairs, sorted by key.
##
## @since 0.1.0
##
## ```
## ➢ Map.to_list (Map.from_list [(2, "two"), (1, "one")])
## [(1, "one"), (2, "two")] : List (Int, String)
## ```
let to_list (map : Map k v) : List (k, v) =
    todo "not implemented"

## Convert a list of key-value pairs into a map.
## If there are duplicate keys, later values overwrite earlier ones.
##
## @since 0.1.0
##
## ```
## ➢ Map.from_list [(1, "one"), (2, "two"), (1, "ONE")]
## {1: "ONE", 2: "two"} : Map Int String
## ```
let from_list (list : List (comparable, v)) : Map comparable v =
    todo "not implemented"

## Get a list of all keys in a map, sorted.
##
## @since 0.1.0
##
## ```
## ➢ Map.keys (Map.from_list [(1, "one"), (2, "two")])
## [1, 2] : List Int
## ```
let keys (map : Map k v) : List k =
    todo "not implemented"

## Get a list of all values in a map, in key order.
##
## @since 0.1.0
##
## ```
## ➢ Map.values (Map.from_list [(1, "one"), (2, "two")])
## ["one", "two"] : List String
## ```
let values (map : Map k v) : List v =
    todo "not implemented"

## Combine two maps, favoring values from the second map when keys overlap.
##
## @since 0.1.0
##
## ```
## ➢ Map.union (Map.from_list [(2, "TWO"), (3, "three")]) (Map.from_list [(1, "one"), (2, "two")])
## {1: "one", 2: "two", 3: "three"} : Map Int String
## ```
let union (map2 : Map comparable v) (map1 : Map comparable v) : Map comparable v =
    todo "not implemented"

## Keep only key-value pairs where the key exists in both maps.
## Values are taken from the first map.
##
## @since 0.1.0
##
## ```
## ➢ Map.intersect (Map.from_list [(2, "TWO"), (3, "three")]) (Map.from_list [(1, "one"), (2, "two")])
## {2: "two"} : Map Int String
## ```
let intersect (map2 : Map comparable v) (map1 : Map comparable v) : Map comparable v =
    todo "not implemented"

## Keep only key-value pairs where the key exists in the first map but not the second.
##
## @since 0.1.0
##
## ```
## ➢ Map.diff (Map.from_list [(2, "TWO"), (3, "three")]) (Map.from_list [(1, "one"), (2, "two")])
## {3: "three"} : Map Int String
## ```
let diff (map2 : Map comparable v) (map1 : Map comparable v) : Map comparable v =
    todo "not implemented"

## Fold over the key-value pairs in a map, in key order from lowest to highest.
##
## @since 0.1.0
##
## ```
## ➢ Map.fold_left (fn k v acc => acc ++ v) "" (Map.from_list [(1, "one"), (2, "two")])
## "onetwo" : String
## ```
let fold_left (f : k -> v -> acc -> acc) (init : acc) (map : Map k v) : acc =
    todo "not implemented"

## Fold over the key-value pairs in a map, in key order from highest to lowest.
##
## @since 0.1.0
##
## ```
## ➢ Map.fold_right (fn k v acc => acc ++ v) "" (Map.from_list [(1, "one"), (2, "two")])
## "twoone" : String
## ```
let fold_right (f : k -> v -> acc -> acc) (init : acc) (map : Map k v) : acc =
    todo "not implemented"

## Transform values in a map.
##
## @since 0.1.0
##
## ```
## ➢ Map.map (fn k v => String.to_upper v) (Map.from_list [(1, "one"), (2, "two")])
## {1: "ONE", 2: "TWO"} : Map Int String
## ```
let map (f : k -> v -> v2) (map : Map k v) : Map k v2 =
    todo "not implemented"

## Keep only key-value pairs that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ Map.keep (fn k v => mod k 2 == 0) (Map.from_list [(1, "one"), (2, "two")])
## {2: "two"} : Map Int String
## ```
let keep (pred : comparable -> v -> Bool) (map : Map comparable v) : Map comparable v =
    todo "not implemented"

## Remove key-value pairs that satisfy the given predicate.
##
## @since 0.1.0
##
## ```
## ➢ Map.reject (fn k v => mod k 2 == 0) (Map.from_list [(1, "one"), (2, "two")])
## {1: "one"} : Map Int String
## ```
let reject (pred : comparable -> v -> Bool) (map : Map comparable v) : Map comparable v =
    todo "not implemented"

## Create two new maps. The first contains all key-value pairs that passed the
## given test, and the second contains all key-value pairs that did not.
##
## @since 0.1.0
##
## ```
## ➢ Map.partition (fn k v => mod k 2 == 0) (Map.from_list [(1, "one"), (2, "two")])
## ({2: "two"}, {1: "one"}) : (Map Int String, Map Int String)
## ```
let partition (pred : comparable -> v -> Bool) (map : Map comparable v) : (Map comparable v, Map comparable v) =
    todo "not implemented"
