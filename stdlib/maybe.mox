module Maybe exposing
  ( Maybe(..)
  , and_then
  , and_then2
  , and_then3
  , and_then4
  , compact
  , flatten
  , from_predicate
  , from_result
  , map
  , map2
  , map3
  , map4
  , next
  , none?
  , one_of
  , or
  , prev
  , satisfy?
  , some?
  , with_default
  , zip
  )

  ## Represent values that may or may not exist.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Some 42
  ## Some 42 : Maybe Int
  ## ```
  type Maybe a =
    | None
    | Some a

  ## Returns `True` when the `Maybe` value was constructed with `Some`.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.some? (Some 42)
  ## True : Bool
  ## ```
  let some? : Maybe a -> Bool =
    \ma =>
      match ma on
      | None => False
      | Some _ => True

  ## Returns `True` when the `Maybe` value is `None`.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.none? (Some 42)
  ## False : Bool
  ## ```
  let none? : Maybe a -> Bool =
    \ma =>
      match ma on
      | None => True
      | Some _ => False

  ## Unwrap a value while providing a default value.
  ## Useful for pipelines, otherwise use a `match` expr instead.
  ## Default value is lazy and will only be computed if the `Maybe` is `None`.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.with_default 100 (Some 42)
  ## 42 : Int
  ##
  ## ➢ Maybe.with_default 100 None
  ## 100 : Int
  ## ```
  let with_default : a -> Maybe a -> a =
    \default ma =>
      match ma on
      | None => default
      | Some a => a

  ## Applies the predicate to a value and lifts the result into a `Maybe`.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.from_predicate ((==) 42) 42
  ## Some 42 : Maybe Int
  ## ```
  let from_predicate : (a -> Bool) -> a -> Maybe a =
    \predicate x =>
      if predicate x then
        Some x
      else
        None

  ## Determines if the wrapped value satisfies a predicate.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.satisfy? (\x => x > 10) (Some 15)
  ## True : Bool
  ## ```
  let satisfy? : (a -> Bool) -> Maybe a -> Bool =
    \predicate ma =>
      match ma on
      | None => False
      | Some a => predicate a

  ## Apply a function to value wrapped by a `Maybe`.
  ## Equivalent of `<$>` from the `Functor` typeclass.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.map ((*) 2) (Some 21)
  ## Some 42 : Maybe Int
  ## ```
  let map : (a -> value) -> Maybe a -> Maybe value =
    \f ma =>
      match ma on
      | None => None
      | Some a => Some (f a)

  ## Apply a function if all the arguments are `Some`'s.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.map2 (+) (Some 21) (Some 21)
  ## Some 42 : Maybe Int
  ## ```
  let map2 : (a -> b -> value) -> Maybe a -> Maybe b -> Maybe value =
    \f ma mb =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b => Some (f a b)

  ## Apply a function if all the arguments are `Some`'s.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.map3 (+) (Some 14) (Some 14) (Some 14)
  ## Some 42 : Maybe Int
  ## ```
  let map3 : (a -> b -> c -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe value =
    \f ma mb mc =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b =>
              match mc on
              | None => None
              | Some c => Some (f a b c)

  ## Apply a function if all the arguments are `Some`'s.
  ##
  ## @since 0.1.0
  let map4 : (a -> b -> c -> d -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe value =
    \f ma mb mc md =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b =>
              match mc on
              | None => None
              | Some c =>
                  match md on
                  | None => None
                  | Some d => Some (f a b c d)

  ## Removes one level of nesting.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.flatten (Some (Some 42))
  ## Some 42 : Maybe Int
  ## ```
  let flatten : Maybe (Maybe a) -> Maybe a =
    \mma =>
      match mma on
      | None => None
      | Some ma => ma

  ## Combines two `Maybe` values into a tuple, if both are `Some`.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.zip (Some "hello word") (Some 42)
  ## Some ("hello world", 42) : Maybe (String, Int)
  ## ```
  let zip : Maybe a -> Maybe b -> Maybe (a, b) =
    \ma mb =>
      match (ma, mb) on
      | Some (a, b) => Some (a, b)
      | _ => None

  ## Equivalent of `<|>` from the `Alternative` typeclass.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.or None (Some 42)
  ## Some 42 : Maybe Int
  ## ```
  let or : Maybe a -> Maybe a -> Maybe a =
    \ma mb =>
      match ma on
      | None => mb
      | Some _ => ma

  ## Equivalent of `>>=` from the `Monad` typeclass.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.and_then (\x -> Some (x * 2)) (Some 21)
  ## Some 42 : Maybe Int
  ## ```
  let and_then : (a -> Maybe value) -> Maybe a -> Maybe value =
    \f ma =>
      match ma on
      | None => None
      | Some a => f a

  ## Equivalent of `>>=` from the `Monad` typeclass.
  ##
  ## @since 0.1.0
  let and_then2 : (a -> b -> Maybe value) -> Maybe a -> Maybe b -> Maybe value =
    \f ma mb =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b => f a b

  ## Equivalent of `>>=` from the `Monad` typeclass.
  ##
  ## @since 0.1.0
  let and_then3 : (a -> b -> c -> Maybe value) -> Maybe a -> Maybe b -> Maybe c -> Maybe value =
    \f ma mb mc =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b =>
              match mc on
              | None => None
              | Some c => f a b c

  ## Equivalent of `>>=` from the `Monad` typeclass.
  ##
  ## @since 0.1.0
  let and_then4 : (a -> b -> c -> d -> Maybe value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe value =
    \f ma mb mc md =>
      match ma on
      | None => None
      | Some a =>
          match mb on
          | None => None
          | Some b =>
              match mc on
              | None => None
              | Some c =>
                  match md on
                  | None => None
                  | Some d => f a b c d

  ## Try a list of functions against a value. Return the value of the first call that succeeds (returns `Some`).
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ "42.0" |> Maybe.one_of [String.to_int, String.to_float]
  ## Some 42.0 : Maybe Float
  ## ```
  let one_of : List (a -> Maybe b) -> a -> Maybe b =
    \fmbs default =>
      match fmbs on
      | [] => None
      | fmb :: rest =>
          match fmb default on
          | None => one_of rest default
          | Some b => Some b

  ## Removes `None` values from a collection while unwrapping all present values.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.compact [Some 1, None, Some 2]
  ## [1, 2] : List Int
  ## ```
  let compact : List (Maybe a) -> List a =
    \maybes =>
      List.collect_map identity maybes

  ## Take two `Maybe` values. If the first one equals `None`, return `None`. Otherwise return the second value.
  ## Allows for chaining `Maybe` computations, with a possible "early return" in case of `None`.
  ## Equivalent of `*>` from the `Applicative` typeclass.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.next (Some 1) (Some 2)
  ## Some 2 : Maybe Int
  ##
  ## ➢ Maybe.next None (Some 2)
  ## None : Maybe Int
  ##
  ## ➢ Maybe.next (Some 1) None
  ## None : Maybe Int
  ## ```
  let next : Maybe a -> Maybe b -> Maybe b =
    \ma mb =>
      match ma on
      | None => None
      | Some _ => mb

  ## Take two `Maybe` values. If the second one equals `None`, return `None`. Otherwise return the first value.
  ## Equivalent of `<*` from the `Applicative` typeclass.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.prev (Some 1) (Some 2)
  ## Some 1 : Maybe Int
  ##
  ## ➢ Maybe.prev None (Some 2)
  ## None : Maybe Int
  ##
  ## ➢ Maybe.prev (Some 1) None
  ## None : Maybe Int
  ## ```
  let prev : Maybe a -> Maybe b -> Maybe a =
    \ma mb =>
      match mb on
      | None => None
      | Some _ => ma

  ## Converts a `Result` to `Maybe`, dropping the error.
  ##
  ## @since 0.1.0
  ##
  ## ```
  ## ➢ Maybe.from_result (Ok 42) : Result String Int
  ## Some 42 : Maybe Int
  ##
  ## ➢ Maybe.from_result (Err "uh oh!") : Result String Int
  ## None : Maybe Int
  ## ```
  let from_result : Result e a -> Maybe a =
    \result =>
      match result on
      | Err _ => None
      | Ok a => Some a
end
